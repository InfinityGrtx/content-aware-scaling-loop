<!DOCTYPE html5>
<html>
	<head>
		<title>Content-Aware Scaler</title>
		<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
		<meta name="viewport" content="width=device-width,initial-scale=1.0">
		<script>window.onerror = function (errorMsg, url, lineNumber) {alert('Error: ' + errorMsg + ' Script: ' + url + ' Line: ' + lineNumber);}</script>
		<style type="text/css">
			canvas{border:none;}
			img,canvas{width:75%;height:auto;}
			#d{-ms-transform:rotate(-90deg);-webkit-transform:rotate(-90deg);transform:rotate(-90deg);}
		</style>
	</head>
	<body><div>
	        <input type="file" id="input" style="visibility:hidden;position:fixed;z-index:-1;bottom:0;right:0;"/>
		<h1>Content-Aware Scaler</h1>
		<input type="checkbox"/> Disable Animated Scaling (speeds up the process)<br>
		<button onclick="doEverything(this,50,window.url);">Scale it!</button><br/>
		<label for="input" style="color:blue;color:pointer;"><h2>Input</h2><br><img id="i" src="image.jpg"/></label><br>
		<h2>Output</h2><br>
		<canvas id="c"></canvas><br>
		<canvas id="d"></canvas><br>
		<h2>Result</h2><br>
		<img id="res"/>
<script type="text/javascript">
	window.url="image.jpg";
	function doEverything(btn,scale,url){
		btn.setAttribute('disabled','disabled');
		var img=document.getElementById('i');
		img.src="";
		img.onload=function(){img.onload=function(){};doCarve(img.src,(scale/100)*img.width,(scale/100)*img.height,function(url,args){document.getElementById("res").src=url;args[0].removeAttribute('disabled');},[btn]);}
		img.src=url;
	}
	async function doCarve(url, x, y, callback, callbackvars){try{
		window.memvas=document.createElement('canvas');
		window.memtext=window.memvas.getContext('2d');
		window.c=new Carver("c",url);
		await new Promise(sleep=>setTimeout(sleep,500));
		while(window.c.w>x){
			window.c.shrink();
			if(!document.querySelector('input[type=checkbox]').selected){await new Promise(sleep=>setTimeout(sleep,window.c.canvas.width/50));}
		}
		var imgc=new Image();
		imgc.src=window.c.canvas.toDataURL();
		imgc.onload=async function(){
		window.memvas.width=window.c.h;
		window.memvas.height=window.c.w;
		window.memtext.save();
		window.memtext.translate(window.memvas.width,window.memvas.height/window.memvas.width);
		window.memtext.rotate(Math.PI/2);
		window.memtext.drawImage(imgc,0,0);
		window.memtext.restore();
		window.d=new Carver("d",window.memvas.toDataURL());
		await new Promise(sleep=>setTimeout(sleep,500));
		while(window.d.w>y){
			window.d.shrink();
			if(!document.querySelector('input[type=checkbox]').selected){await new Promise(sleep=>setTimeout(sleep,window.d.canvas.width/50));}
		}
		var imgd=new Image();
		imgd.src=window.d.canvas.toDataURL();
		imgd.onload=async function(){
		window.memvas.width=window.d.h;
		window.memvas.height=window.d.w;
		window.memtext.save();
		window.memtext.translate(window.memvas.width,window.memvas.height/window.memvas.width);
		window.memtext.rotate(Math.PI/2);
		window.memtext.scale(-1,-1);
		window.memtext.drawImage(imgd,window.memvas.width,window.memvas.height);
		window.memtext.restore();
		callback(window.memvas.toDataURL(),callbackvars);
		}
		}
	}catch(e){alert(e);}}
	function Carver(canvasId, url) {
		// create canvas & drawing context
		this.canvas = document.getElementById(canvasId);
		this.context = this.canvas.getContext('2d');
		var carver = this;
		// load image
		var img = new Image();
		img.onload = function() {
			w = this.width;
			h = this.height;
			carver.canvas.width = w;
			carver.canvas.height = h;
			carver.context.drawImage(img,0,0,w,h);
			carver.w = w;
			carver.h = h;
			carver.img=img;
		};
		img.src = url; // trigger image loading
		this.shrink = function() {
			// get raw data
			var raw = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);
			// difference between two pixels (color vector distance)
			var pixel_diff = function(x0,y0, x1,y1) {
				var offset0 = 4 * (carver.canvas.width * y0 + x0);
				var r0 = raw.data[offset0];
				var g0 = raw.data[offset0 + 1];
				var b0 = raw.data[offset0 + 2];
				var offset1 = 4 * (carver.canvas.width * y1 + x1);
				var r1 = raw.data[offset1];
				var g1 = raw.data[offset1 + 1];
				var b1 = raw.data[offset1 + 2];
				return Math.sqrt(Math.pow(r0 - r1, 2) +
					Math.pow(g0 - g1, 2) +
					Math.pow(b0 - b1, 2));
			};
			var lowest_score = null;
			var lowest_points = null;
			for(i = 0; i < this.w; ++i) { // for each column
				var score = 0;	// column score
				var x = i; // starting from i, look around.
				var path = new Array(); // storing the points to be removed.
				for(j = 0; j < this.h; j++) {
					var lots = Math.pow(10, 30);
					var delta_left = lots, delta_here = lots, delta_right = lots;
					path.push([x, j]);
					if(j == this.h - 1) {
						break;
					}
					// comparison between the current pixel and the one under
					delta_here = pixel_diff(x, j, x, j+1);

					// if there is a pixel on the left, check how different it is.
					if(x != 0) {
						delta_left = pixel_diff(x, j, x-1, j+1);
					}
					// if there is a pixel on the right, check how different it is.
					if(x != w-1) {
						delta_right = pixel_diff(x, j, x+1, j+1);
					}
					// check which way we're going next.
					if(delta_left < delta_here && delta_left < delta_right) {
						x--; // go down left
						score += delta_left;
					} else if(delta_right < delta_here && delta_right < delta_left) {
						x++; // go down right
						score += delta_right;
					} else { // go down
						score += delta_here;
					}
					if(lowest_score != null && score > lowest_score) {
						break; // no point continuing
					}
				}
				// save the path with the lowest score
				if(lowest_score == null || score < lowest_score) {
					lowest_score = score;
					lowest_points = path;
				}
			}
			// remove the squiggly “line” of points with the lowest score, row by row.
			for(p = 0; p < lowest_points.length; p++) {
				var x = lowest_points[p][0];
				var y = lowest_points[p][1];
				// shifts all pixels on the right of the selected path one position to the left.
				for(i = x; i < this.w-1; i++) {
					var offset = 4 * (this.canvas.width * y + i);
					raw.data[offset] = raw.data[offset+4];
					raw.data[offset+1] = raw.data[offset+5];
					raw.data[offset+2] = raw.data[offset+6];
					raw.data[offset+3] = raw.data[offset+7];
				}
				// add a single white pixel to the right of the row
				offset = 4 * (this.canvas.width * y + this.w-1);
				raw.data[offset] = 255;
				raw.data[offset+1] = 255;
				raw.data[offset+2] = 255;
			}
			this.context.putImageData(raw, 0, 0);
			// now dealing with one less column
			this.w--;
		};
	}
	document.querySelector('#input').onchange=function(){
	var file = document.querySelector('#input').files[0];
	var reader = new FileReader();
	reader.addEventListener("load",function(){
		window.url=reader.result;
		document.getElementById("i").src=window.url;
	},false);
	if(file){reader.readAsDataURL(file);}
	}
</script>
</div></body>
</html>
